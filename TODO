

Allow structs/unions to be "unpacked" into each other.
So like:

    struct A:
        name: sym
        !unpack union:
            number: int
            string: sym

...compiles to:

    struct A {
        const char *name;
        int tag;
        union {
            int number;
            const char *string;
        } u;
    };

...k wait a minute. Doesn't it seem more like we want a single TYPE_TAG_STRUCT
which compiles to a C struct and is allowed to have a single union (int tag + union u)?
What would syntax for that look like?

    struct A:
        name: sym
        !union:
            number: int
            string: sym

...and then, is it a syntax error to use "!union" more than once in same struct?
I don't think so; I think type->u.struct_f just ends up having struct_fields and
union_fields, and if union_fields is empty then struct is compiled to C with no
"int tag / union u" combo.
(What if someone wants to force an empty union with "!union()"?.. probably we
don't allow it)




We've added TYPE_TAG_FUNCTION, now we need to add methods.
Function/method type syntax:

    (function | method) [NAME]:
        [ret: TYPE]
        args: [NAME([out] TYPE) ...]

...is "self" ("this"?) automatically generated as first argument?..
No, I think let's actually get rid of "staticmethod" and have all methods
be "static" in the sense that they just represent C functions with arbitrary
arguments, *BUT* if we start adding scripting, then we can add a special
operator which attempts to call a method passing its object as first argument.
So for now we don't have to worry about that.




Require type.h for out compiled output, change runtime's type_t to type_info_t,
and move the runtime stuff into runtime.[ch] (instead of writing it out in
compiler_write.c).






Figure out how parsing and writing are going to work.
In particular, how is that going to work with weakrefs?
It would be cool if the fus syntax could do pointers, I guess.


